/*
  Copyright 2011-2016 Marvell Semiconductor, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
var READY = false, SECOND = 1000, TRACE_ERRORS=false;var nextorigin = (function() {    var max = 20, ori = Math.floor(Math.random() * max);    return function( origin, failover ) {        return origin.indexOf('pubsub.') > 0            && origin.replace(             'pubsub', 'ps' + (                failover ? uuid().split('-')[0] :                (++ori < max? ori : ori=1)            ) ) || origin;    }})();function uuid(callback) {    var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,    function(c) {        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);        return v.toString(16);    });    if (callback) callback(u);    return u;}function each( o, f) {    if ( !o || !f ) return;    if ( Array.isArray(o) )        for ( var i = 0, l = o.length; i < l; )            f.call( o[i], o[i], i++ );    else        for ( var i in o )            o.hasOwnProperty    &&            o.hasOwnProperty(i) &&            f.call( o[i], i, o[i] );}function map( list, fun ) {    var fin = [];    each( list || [], function( k, v ) { fin.push(fun( k, v )) } );    return fin;}function PN_API(setup) {    var PUBLISH_KEY   = setup['publish_key']   || 'demo'    ,   SUBSCRIBE_KEY = setup['subscribe_key'] || 'demo'    ,   ORIGIN        = 'http://'+(setup['origin']||'pubsub.pubnub.com')    ,   STD_ORIGIN    = nextorigin(ORIGIN)    ,   SUB_ORIGIN    = nextorigin(ORIGIN)    ,   CONNECT       = function(){}    ,   PUB_QUEUE     = []    ,   SUB_RECEIVER  = 0    ,   TIMETOKEN     = 0    ,   CHANNELS      = {}    ,   xdr           = setup['xdr']    ,   params        = setup['params'] || {}    ,   error         = function(message) {if (TRACE_ERRORS) trace("PubNub Error: "+message+"\n")}    ,   _is_online    = function() { return 1 }    ,   UUID          = setup['uuid'] || ''    ,   _poll_timer;    function _get_url_params(data) {    	if (!data) data = {};        each( params , function( key, value ) {            if (!(key in data)) data[key] = value;        });        return data;    }    function publish(next) {        if (next) PUB_QUEUE.sending = 0;        if ( PUB_QUEUE.sending || !PUB_QUEUE.length ) return;        PUB_QUEUE.sending = 1;        xdr(PUB_QUEUE.shift());    }    var SELF = {         'history' : function( args, callback ) {            var callback         = args['callback'] || callback            ,   count            = args['count']    || args['limit'] || 100            ,   reverse          = args['reverse']  || "false"            ,   channel          = args['channel'];            if (!channel) return error('Missing Channel');            if (!callback)      return error('Missing Callback');            var params = { 'stringtoken': 'true', 'count': count, 'reverse': reverse };            xdr({                data     : _get_url_params(params),                success  : function(response) {                    if (typeof response == 'object' && response['error']) {                        error(JSON.stringify({'message' : response['message'], 'payload' : response['payload']}));                        return;                    }                    var messages = response[0];                    callback([messages, response[1], response[2]]);                },                fail     : function(response) {                    error(JSON.stringify(response));                },                url      : [                    STD_ORIGIN, 'v2', 'history', 'sub-key',                    SUBSCRIBE_KEY, 'channel', encodeURIComponent(channel)                ]            });        },        'time' : function(callback) {            xdr({                data     : _get_url_params({ 'uuid' : UUID }),                timeout  : SECOND * 5,                url      : [STD_ORIGIN, 'time', 0],                success  : function(response) { callback(response[0]) },                fail     : function() { callback(0) }            });        },        'publish' : function( args ) {            var msg      = args['message']            ,   callback = args['callback'] || function(){}            ,   channel  = args['channel']             ,   err      = args['error'] || function() {}            ,   url;            if (!msg) return error('Missing Message');            if (!channel)       return error('Missing Channel');            msg = JSON['stringify'](msg);            url = [                STD_ORIGIN, 'publish',                PUBLISH_KEY, SUBSCRIBE_KEY,                0, encodeURIComponent(channel),                0, encodeURIComponent(msg)            ];            params = { 'uuid' : UUID }            PUB_QUEUE['push']({                timeout  : SECOND * 5,                url      : url,                data     : _get_url_params(params),                fail     : function(response){                    error(JSON.stringify(response));                    publish(1);                },                success  : function(response) {                	if (typeof response == 'object') {			            if (response['error'] && response['message'] && response['payload']) {			                err({'message' : response['message'], 'payload' : response['payload']});			                return;			            }			            if (response['payload']) {			                callback(response['payload']);			                return;			            }			        }			        callback(response);                    publish(1);                },                mode     : 'GET'            });            publish();        },        'subscribe' : function( args ) {            var channel         = args['channel']            ,   callback        = args['callback'] || args['message']            ,   timetoken       = args['timetoken']   || 0;            TIMETOKEN = timetoken;            if (!channel) return error('Missing Channel');            if (!callback) return error('Missing Callback');            let CHANNEL = {                name         : channel,                connected    : undefined,                disconnected : undefined,                subscribed   : 1,                callback     : callback,            };            function _test_connection(success) {                if (success) {                    pubNubContent.setTimeout(CONNECT, SECOND );                }                else {                    STD_ORIGIN = nextorigin( ORIGIN, 1 );                    SUB_ORIGIN = nextorigin( ORIGIN, 1 );                    pubNubContent.setTimeout(function() {                        SELF['time'](_test_connection);                    }, SECOND );                }                    if (success && CHANNEL.disconnected) {                        CHANNEL.disconnected = 0;                        return;                    }                    if (!success && !CHANNEL.disconnected) {                        CHANNEL.disconnected = 1;                    }                           }            function _connect() {                let channels        = CHANNEL.name;                if (!channels) channels = ',';                _reset_offline();                var data = _get_url_params({ 'uuid' : UUID });                let SUB_RECEIVER = xdr({                    timeout  : 310000,                    fail     : function(response) {                        SELF['time'](function(success){                            if (!success) error(JSON.stringify(response));                            _test_connection(success);                        });                    },                    data     : _get_url_params(data),                    url      : [                        SUB_ORIGIN, 'subscribe',                        SUBSCRIBE_KEY, encodeURIComponent(channels),                        0, TIMETOKEN                    ],                    success : function(messages) {                        if (!messages || (                            typeof messages == 'object' &&                            'error' in messages         &&                            messages['error']                        )) {                            error(messages['error']);                            return pubNubContent.setTimeout(CONNECT, SECOND );                        }                        TIMETOKEN = !TIMETOKEN &&  messages[1];                                var next_callback = (function() {                            var channels = '';                            if (messages.length > 3) {                                channels = messages[3];                            } else if (messages.length > 2) {                                channels = messages[2];                            } else {                                channels =  map(                                    {CHANNEL}, function(chan) { return map(                                        Array(messages[0].length)                                        .join(',').split(','),                                        function() { return chan; }                                    ) }).join(',')                            }                            var list = channels.split(',');                            return function() {                                var channel = list.shift();                                return [                                    (CHANNEL||{}).callback,                                    channel.split('-pnpres')[0]                                ];                            };                        })();                        each( messages[0], function(msg) {                            var next = next_callback();                            next[0]( msg, messages, next[2] || next[1] );                        });                        pubNubContent.setTimeout(_connect, 10 );                    }                });            }            CONNECT = function() {                _reset_offline();                pubNubContent.setTimeout(_connect, 10 );            };            CONNECT();        },        'xdr'           : xdr,        'uuid'          : uuid,        'map'           : map,        'each'          : each,        'offline'       : function(){_reset_offline(1, { "message":"Offline. Please check your network settings." })},    };    function _poll_online() {        _is_online() || _reset_offline( 1, {            "error" : "Offline. Please check your network settings. "        });        _poll_timer = pubNubContent.setTimeout(_poll_online, SECOND );    }    function _reset_offline(err, msg) {        SUB_RECEIVER && SUB_RECEIVER(err, msg);        SUB_RECEIVER = null;    }    if (!UUID) UUID = SELF['uuid']();    _poll_timer = pubNubContent.setTimeout( _poll_online,  SECOND    );    return SELF;}function xdr( setup ) {    if (!("data" in setup))        setup.data = {};    setup.data['pnsdk'] = 'PubNub-JS-KinomaJS/Kinoma.1';    if (!("timeout" in setup))        setup.timeout = 310000;    return pubNubContent.xdr(setup);}function error(message) { console['error'](message) }function CREATE_PUBNUB(setup) {    setup['xdr'] = xdr;    setup['error'] = setup['error'] || error;    setup['params']      = { 'pnsdk' : 'PubNub-JS-KinomaJS/Kinoma.1' }    let SELF = function(setup) {        return CREATE_PUBNUB(setup);    }    var PN = PN_API(setup);    for (var prop in PN) {        if (PN.hasOwnProperty(prop)) {            SELF[prop] = PN[prop];        }    }    pubNubContent.setTimeout(function() {	    if (READY) return;	    READY = 1;	}, SECOND );    return SELF;}CREATE_PUBNUB['init'] = CREATE_PUBNUBexport var PUBNUB = CREATE_PUBNUB;Handler.bind("/timeHandler", {  onInvoke: function(handler, message){    handler.wait(message.requestObject.delay);  },});var pubNubContent = {    setTimeout: function(callback, delay) {        var timer = {            callback: callback,            time: delay,        };        new MessageWithObject("/timeHandler", {delay:delay}).invoke().then(message => {             timer.callback.call(null, timer);        });        return timer;    },        xdr: function(request) {        	var url = request.url.join('/'), params = [];            if (!request.data) return url;            each(  request.data, function( key, value ) {                var value_str = (typeof value == 'object')?JSON['stringify'](value):value;                (typeof value != 'undefined' &&                    value != null && encodeURIComponent(value_str).length > 0                ) && params.push(key + "=" + encodeURIComponent(value_str));            } );            url += "?" + params.join('&');            var message = new Message(url);            var cancel = function(failed, json) {            	var request = pubNubContent.deleteRequest(url);                if (request) {                    //message.cancel();                    if (failed) {                        if ("fail" in request)                            request.fail.call(null, json);                    }                    else {                        if ("success" in request)                            request.success.call(null, json);                    }                }            }            request.URL = url;            request.nextRequest = this.nextRequest;            this.nextRequest = request;            request.timer = this.setTimeout(function() { cancel(1) }, request.timeout);            message.invoke(Message.TEXT).then(text => {                 var url = message.url;                var oldRequest = request;                var request = this.deleteRequest(url);				if (request) {                    var json = null;                    if (text) {                        try {                            json = JSON.parse(text);                        }                        catch (e) {                             json = { "error" : "JSON Error"}                        }                    }                    else {                        json = { "error" : "Network Connection Error"}                    }                    if (message.status == 200) {                        if ("success" in request) {                            request.success.call(null, json);                         }                    }                    else {                        if ("fail" in request) {                            request.fail.call(null, json);                        }                    }                       }              });            return cancel;        },    deleteRequest: function(url) {        var former = this, current;        while (current = former.nextRequest) {            if (current.URL == url) {                former.nextRequest = current.nextRequest;                current.nextRequest = null;                return current;            }            former = current;        }        return null;    }};